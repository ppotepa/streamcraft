<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>SC2 Plugin Configuration</title>
    <style>
        :root {
            color-scheme: dark;
            --bg: #060508;
            --panel: #11111a;
            --accent: #3ef4c5;
            --accent-fg: #041b14;
            --muted: #7c7d8a;
            --border: #1e1e2a;
            font-family: "Space Grotesk", "Segoe UI", system-ui, sans-serif;
        }

        body {
            margin: 0;
            background: radial-gradient(circle at top left, #101026, var(--bg));
            color: #f7f8fa;
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 32px 16px;
        }

        .config-shell {
            width: min(640px, 100%);
            background: rgba(8, 8, 14, 0.9);
            border: 1px solid var(--border);
            border-radius: 18px;
            box-shadow: 0 25px 65px rgba(0, 0, 0, 0.65);
            backdrop-filter: blur(12px);
            padding: 32px;
        }

        header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 12px;
            margin-bottom: 24px;
        }

        h1 {
            margin: 0;
            font-size: 1.8rem;
            letter-spacing: 0.05em;
        }

        header p {
            margin: 6px 0 0;
            color: var(--muted);
            max-width: 360px;
            line-height: 1.4;
        }

        button.clear-storage {
            border: none;
            background: rgba(255, 255, 255, 0.08);
            color: #fff;
            padding: 10px 16px;
            border-radius: 999px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: background 160ms ease, transform 160ms ease;
        }

        button.clear-storage:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-1px);
        }

        .status-bar {
            font-size: 0.85rem;
            color: var(--muted);
            margin-bottom: 18px;
        }

        .status-bar.error {
            color: #ff9595;
        }

        section.config-section {
            border: 1px solid var(--border);
            border-radius: 14px;
            padding: 20px;
            margin-bottom: 20px;
            background: var(--panel);
        }

        section.config-section h2 {
            font-size: 1.1rem;
            margin: 0 0 6px;
        }

        section.config-section p {
            margin: 0 0 14px;
            color: var(--muted);
        }

        label.config-field {
            display: flex;
            flex-direction: column;
            gap: 6px;
            margin-bottom: 16px;
        }

        label.config-field span {
            font-size: 0.95rem;
            letter-spacing: 0.03em;
        }

        label.config-field small {
            color: var(--muted);
            font-size: 0.8rem;
        }

        input.config-input {
            background: #05060c;
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 12px;
            color: #fff;
            font-size: 1rem;
            transition: border 160ms ease, box-shadow 160ms ease;
        }

        input.config-input:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 2px rgba(62, 244, 197, 0.2);
        }

        input.config-input.invalid {
            border-color: #ff6161;
            box-shadow: 0 0 0 2px rgba(255, 97, 97, 0.2);
        }

        .helper-row {
            display: flex;
            justify-content: space-between;
            font-size: 0.8rem;
            color: var(--muted);
        }

        @media (max-width: 600px) {
            body {
                padding: 16px;
            }

            .config-shell {
                padding: 20px;
            }

            header {
                flex-direction: column;
            }
        }
    </style>
</head>

<body>
    <main class="config-shell">
        <header>
            <div>
                <h1>SC2 Plugin Settings</h1>
                <p>Provide your BattleTag so the background runner can tell which lobby player is you. Values are stored
                    locally and synced to the runner.</p>
            </div>
            <button id="reset-storage" class="clear-storage">Reset Local Copy</button>
        </header>
        <div id="status" class="status-bar">Loading configuration…</div>
        <section id="config-root">
            <div class="config-section">
                <p>Preparing fields…</p>
            </div>
        </section>
    </main>

    <script>
        (() => {
            const basePath = window.location.pathname.replace(/\/$/, '');
            const schemaUrl = `${basePath}/schema`;
            const valueUrl = `${basePath}/value`;
            const storageKey = 'streamcraft.sc2.config';
            const statusEl = document.getElementById('status');
            const root = document.getElementById('config-root');
            const resetButton = document.getElementById('reset-storage');
            const state = {
                schema: [],
                values: {},
                local: {}
            };
            let saveHandle = null;

            const setStatus = (message, isError = false) => {
                statusEl.textContent = message;
                statusEl.classList.toggle('error', isError);
            };

            const loadLocal = () => {
                try {
                    const raw = localStorage.getItem(storageKey);
                    return raw ? JSON.parse(raw) : {};
                } catch (error) {
                    console.warn('Unable to read local storage', error);
                    return {};
                }
            };

            const persistLocal = values => {
                try {
                    localStorage.setItem(storageKey, JSON.stringify(values));
                } catch (error) {
                    console.warn('Unable to persist local storage', error);
                }
            };

            const fetchJson = async url => {
                const response = await fetch(url, { cache: 'no-store' });
                if (!response.ok) {
                    throw new Error(`Request failed: ${response.status}`);
                }
                return await response.json();
            };

            const buildField = (sectionEl, field, value) => {
                const label = document.createElement('label');
                label.className = 'config-field';

                const caption = document.createElement('span');
                caption.textContent = field.label;
                label.appendChild(caption);

                if (field.description) {
                    const helper = document.createElement('small');
                    helper.textContent = field.description;
                    label.appendChild(helper);
                }

                const input = document.createElement('input');
                input.className = 'config-input';
                input.type = 'text';
                input.placeholder = field.placeholder || '';
                input.value = value ?? '';
                input.autocomplete = 'off';
                input.spellcheck = false;
                input.dataset.key = field.key;
                if (field.validationPattern) {
                    input.pattern = field.validationPattern;
                }

                input.addEventListener('input', () => handleFieldInput(field, input));
                label.appendChild(input);

                sectionEl.appendChild(label);
                validateField(field, input.value, input);
            };

            const render = () => {
                root.innerHTML = '';

                if (!state.schema.length) {
                    const placeholder = document.createElement('div');
                    placeholder.className = 'config-section';
                    placeholder.textContent = 'No configurable fields were provided for this plugin.';
                    root.appendChild(placeholder);
                    return;
                }

                state.schema.forEach(section => {
                    const sectionEl = document.createElement('section');
                    sectionEl.className = 'config-section';

                    const title = document.createElement('h2');
                    title.textContent = section.title;
                    sectionEl.appendChild(title);

                    if (section.description) {
                        const desc = document.createElement('p');
                        desc.textContent = section.description;
                        sectionEl.appendChild(desc);
                    }

                    section.fields.forEach(field => {
                        const currentValue = state.values[field.key] ?? field.defaultValue ?? '';
                        state.values[field.key] = currentValue;
                        buildField(sectionEl, field, currentValue);
                    });

                    root.appendChild(sectionEl);
                });
            };

            const handleFieldInput = (field, input) => {
                const trimmed = input.value.trim();
                state.values[field.key] = trimmed;
                persistLocal(state.values);
                const valid = validateField(field, trimmed, input);

                if (valid) {
                    setStatus('Saved locally · Syncing…');
                    queueSave();
                } else {
                    setStatus('Fix highlighted fields to sync.', true);
                }
            };

            const validateField = (field, value, input) => {
                let valid = true;

                if (field.required && !value) {
                    valid = false;
                }

                if (valid && field.validationPattern && value) {
                    try {
                        valid = new RegExp(field.validationPattern).test(value);
                    } catch (error) {
                        console.warn('Invalid validation pattern', error);
                    }
                }

                input.classList.toggle('invalid', !valid);
                return valid;
            };

            const queueSave = () => {
                if (saveHandle) {
                    clearTimeout(saveHandle);
                }

                saveHandle = window.setTimeout(saveToServer, 450);
            };

            const saveToServer = async () => {
                saveHandle = null;
                try {
                    const response = await fetch(valueUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(state.values)
                    });

                    if (!response.ok) {
                        const details = await response.text();
                        throw new Error(details || 'Failed to save configuration.');
                    }

                    setStatus('Saved to runner ✓');
                } catch (error) {
                    console.error(error);
                    setStatus(error.message || 'Unable to save configuration.', true);
                }
            };

            resetButton.addEventListener('click', () => {
                localStorage.removeItem(storageKey);
                setStatus('Local storage cleared. Reloading…');
                bootstrap();
            });

            const bootstrap = async () => {
                try {
                    setStatus('Loading configuration…');
                    const [schemaPayload, valuePayload] = await Promise.all([
                        fetchJson(schemaUrl),
                        fetchJson(valueUrl)
                    ]);

                    state.schema = schemaPayload.sections ?? [];
                    state.local = loadLocal();
                    state.values = { ...valuePayload, ...state.local };
                    render();
                    setStatus('Values synced. Update your BattleTag below.');
                } catch (error) {
                    console.error(error);
                    setStatus(error.message || 'Unable to load configuration.', true);
                }
            };

            bootstrap();
        })();
    </script>
</body>

</html>