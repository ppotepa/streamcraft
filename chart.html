<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MMR History Chart - Library Comparison</title>
    <!-- 1. Chart.js with Financial Plugin -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.js"></script>
    <script
        src="https://cdn.jsdelivr.net/npm/chartjs-chart-financial@0.2.0/dist/chartjs-chart-financial.min.js"></script>
    <script
        src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <!-- 2. Lightweight Charts (TradingView) -->
    <script src="https://unpkg.com/lightweight-charts@4.1.3/dist/lightweight-charts.standalone.production.js"></script>
    <!-- 3. ECharts -->
    <script src="https://cdn.jsdelivr.net/npm/echarts@5.4.3/dist/echarts.min.js"></script>
    <!-- 4. Highcharts -->
    <script src="https://code.highcharts.com/stock/highstock.js"></script>
    <!-- 5. Plotly.js -->
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <!-- 6. ApexCharts -->
    <script src="https://cdn.jsdelivr.net/npm/apexcharts@3.45.1/dist/apexcharts.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0a0e1a 0%, #1a1f2e 100%);
            color: #e0e0e0;
            padding: 20px;
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            margin-bottom: 10px;
            color: #00d4ff;
            font-size: 2.5em;
            text-shadow: 0 0 20px rgba(0, 212, 255, 0.5);
        }

        .subtitle {
            text-align: center;
            margin-bottom: 30px;
            color: #888;
            font-size: 0.9em;
        }

        .controls {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            background: rgba(255, 255, 255, 0.05);
            padding: 20px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .control-group label {
            font-size: 0.85em;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        select,
        button {
            padding: 10px 15px;
            border: 1px solid rgba(0, 212, 255, 0.3);
            background: rgba(0, 0, 0, 0.3);
            color: #e0e0e0;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
        }

        select:hover,
        button:hover {
            border-color: #00d4ff;
            background: rgba(0, 212, 255, 0.1);
        }

        button {
            background: linear-gradient(135deg, rgba(0, 212, 255, 0.2), rgba(0, 176, 244, 0.2));
        }

        button:active {
            transform: scale(0.98);
        }

        .charts-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin-bottom: 30px;
        }

        .chart-container {
            position: relative;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            height: 400px;
        }

        .chart-container h3 {
            text-align: center;
            color: #00d4ff;
            margin-bottom: 10px;
            font-size: 1.2em;
            text-shadow: 0 0 10px rgba(0, 212, 255, 0.5);
        }

        .chart-wrapper {
            width: 100%;
            height: calc(100% - 40px);
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .stat-card {
            background: rgba(255, 255, 255, 0.05);
            padding: 20px;
            border-radius: 10px;
            border-left: 4px solid;
            backdrop-filter: blur(10px);
        }

        .stat-card.terran {
            border-left-color: #4169E1;
        }

        .stat-card.protoss {
            border-left-color: #FFD700;
        }

        .stat-card.zerg {
            border-left-color: #9370DB;
        }

        .stat-label {
            font-size: 0.85em;
            color: #888;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 1.8em;
            font-weight: bold;
            color: #00d4ff;
        }

        .legend {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-top: 15px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            padding: 8px 15px;
            border-radius: 5px;
            transition: background 0.3s;
        }

        .legend-item:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        .legend-color {
            width: 30px;
            height: 4px;
            border-radius: 2px;
        }

        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.95);
            border: 1px solid rgba(0, 212, 255, 0.5);
            border-radius: 8px;
            padding: 12px;
            pointer-events: none;
            font-size: 13px;
            z-index: 1000;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }

        .zoom-info {
            text-align: center;
            margin-top: 10px;
            font-size: 0.85em;
            color: #666;
        }

        input[type="text"] {
            padding: 10px 15px;
            border: 1px solid rgba(0, 212, 255, 0.3);
            background: rgba(0, 0, 0, 0.3);
            color: #e0e0e0;
            border-radius: 5px;
            font-size: 14px;
            transition: all 0.3s;
        }

        input[type="text"]:focus {
            outline: none;
            border-color: #00d4ff;
            background: rgba(0, 212, 255, 0.05);
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #00d4ff;
            font-size: 1.2em;
        }

        .error {
            background: rgba(255, 0, 0, 0.1);
            border: 1px solid rgba(255, 0, 0, 0.3);
            padding: 15px;
            border-radius: 8px;
            color: #ff6b6b;
            margin-bottom: 20px;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        .loading::after {
            content: 'âš¡';
            display: inline-block;
            animation: spin 1s linear infinite;
            margin-left: 10px;
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>âš¡ MMR History Visualizer</h1>
        <p class="subtitle">SC2 Pulse Style - Interactive Chart with Zoom & Pan</p>

        <div class="controls">
            <div class="control-group" style="flex: 1; min-width: 300px;">
                <label>Player Account ID</label>
                <input type="text" id="accountId" placeholder="e.g., 315071" value="315071" style="width: 100%;">
            </div>

            <div class="control-group">
                <label>Region</label>
                <select id="region">
                    <option value="201">US</option>
                    <option value="202">EU</option>
                    <option value="203">KR</option>
                </select>
            </div>

            <div class="control-group">
                <label>Queue Type</label>
                <select id="queueType">
                    <option value="2-1">1v1</option>
                    <option value="3-0">2v2</option>
                    <option value="4-0">3v3</option>
                    <option value="5-0">4v4</option>
                </select>
            </div>

            <div class="control-group">
                <label>Data Source</label>
                <div style="display: flex; align-items: center; gap: 10px;">
                    <input type="checkbox" id="useCachedData" style="width: auto; cursor: pointer;">
                    <label for="useCachedData"
                        style="margin: 0; cursor: pointer; text-transform: none; letter-spacing: normal; color: #e0e0e0;">Use
                        Cached Data</label>
                </div>
            </div>

            <div class="control-group">
                <label>Load Data</label>
                <button id="loadData">ðŸ”„ Fetch MMR History</button>
            </div>

            <div class="control-group">
                <label>Time Range</label>
                <select id="timeRange">
                    <option value="7">Last 7 Days</option>
                    <option value="14">Last 14 Days</option>
                    <option value="30">Last 30 Days</option>
                    <option value="60" selected>Last 60 Days</option>
                    <option value="all">All Time</option>
                </select>
            </div>

            <div class="control-group">
                <label>Chart Type</label>
                <select id="chartType">
                    <option value="line" selected>Line Chart</option>
                    <option value="bar">Bar Chart</option>
                </select>
            </div>

            <div class="control-group">
                <label>Performance</label>
                <select id="performance">
                    <option value="normal" selected>Normal (Smooth)</option>
                    <option value="fast">Fast (Optimized)</option>
                </select>
            </div>

            <div class="control-group">
                <label>Actions</label>
                <button id="resetZoom">Reset Zoom</button>
            </div>

            <div class="control-group">
                <label>Y-Axis</label>
                <select id="yAxisStart">
                    <option value="auto" selected>Auto Scale</option>
                    <option value="zero">Start at Zero</option>
                </select>
            </div>
        </div>

        <div class="charts-grid">
            <div class="chart-container">
                <h3>ðŸ“Š Chart.js</h3>
                <canvas id="chartjsChart" class="chart-wrapper"></canvas>
            </div>

            <div class="chart-container">
                <h3>ðŸ“ˆ Lightweight Charts</h3>
                <div id="lightweightChart" class="chart-wrapper"></div>
            </div>

            <div class="chart-container">
                <h3>ðŸ“‰ ECharts</h3>
                <div id="echartsChart" class="chart-wrapper"></div>
            </div>

            <div class="chart-container">
                <h3>ðŸ“Š Highcharts</h3>
                <div id="highchartsChart" class="chart-wrapper"></div>
            </div>

            <div class="chart-container">
                <h3>ðŸ“‰ Plotly.js</h3>
                <div id="plotlyChart" class="chart-wrapper"></div>
            </div>

            <div class="chart-container">
                <h3>ðŸ“Š ApexCharts</h3>
                <div id="apexChart" class="chart-wrapper"></div>
            </div>
        </div>

        <div class="stats" id="stats"></div>
    </div>

    <script>
        let MMR_DATA = null;
        let charts = {
            chartjs: null,
            lightweight: null,
            echarts: null,
            highcharts: null,
            plotly: null,
            apex: null
        };

        const RACE_MAP = {
            '1': 'terran',
            '2': 'protoss',
            '3': 'zerg',
            '4': 'random'
        };

        const RACE_COLORS = {
            terran: { upColor: '#00FF00', downColor: '#FF0000', borderColor: '#00FF00', wickColor: '#00FF00', borderDownColor: '#FF0000', wickDownColor: '#FF0000' },
            protoss: { upColor: '#00FF00', downColor: '#FF0000', borderColor: '#00FF00', wickColor: '#00FF00', borderDownColor: '#FF0000', wickDownColor: '#FF0000' },
            zerg: { upColor: '#00FF00', downColor: '#FF0000', borderColor: '#00FF00', wickColor: '#00FF00', borderDownColor: '#FF0000', wickDownColor: '#FF0000' },
            random: { upColor: '#00FF00', downColor: '#FF0000', borderColor: '#00FF00', wickColor: '#00FF00', borderDownColor: '#FF0000', wickDownColor: '#FF0000' }
        };

        let currentConfig = {
            timeRange: 60,
            aggregationPeriod: 'daily' // hourly, daily, weekly
        };

        // Fetch MMR data from SC2 Pulse API
        async function fetchMmrData() {
            const useCachedData = document.getElementById('useCachedData').checked;

            // If using cached data, load from chart.json
            if (useCachedData) {
                console.log('Loading cached data from chart.json...');
                showLoading();
                hideError();

                try {
                    const response = await fetch('chart.json');
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }

                    const data = await response.json();
                    console.log('Loaded cached data:', data);

                    if (!data || data.length === 0) {
                        throw new Error('No MMR history found in cached data');
                    }

                    // Parse the cached data (same format as API response)
                    MMR_DATA = {};
                    for (const teamData of data) {
                        if (!teamData.staticData || !teamData.history) continue;

                        const legacyId = teamData.staticData.LEGACY_ID;
                        const raceId = legacyId.split('.').pop();
                        const raceName = RACE_MAP[raceId];

                        if (raceName && teamData.history.TIMESTAMP && teamData.history.RATING) {
                            MMR_DATA[raceName] = {
                                timestamps: teamData.history.TIMESTAMP,
                                ratings: teamData.history.RATING
                            };
                        }
                    }

                    hideLoading();

                    if (Object.keys(MMR_DATA).length === 0) {
                        throw new Error('No valid race data found in cached data');
                    }

                    return true;
                } catch (error) {
                    console.error('Error loading cached data:', error);
                    hideLoading();
                    showError(`Failed to load cached data: ${error.message}`);
                    return false;
                }
            }

            // Otherwise, fetch from API (existing logic)
            const accountId = document.getElementById('accountId').value.trim();
            const region = document.getElementById('region').value;
            const queueType = document.getElementById('queueType').value;

            if (!accountId) {
                showError('Please enter an account ID');
                return false;
            }

            showLoading();
            hideError();

            try {
                const baseUid = `${region}-0-${queueType}.${accountId}`;
                const uids = ['1', '2', '3', '4'].map(raceId => `${baseUid}.${raceId}`);

                const params = new URLSearchParams();
                uids.forEach(uid => params.append('teamLegacyUid', uid));
                params.append('groupBy', 'LEGACY_UID');
                params.append('static', 'LEGACY_ID');
                params.append('history', 'TIMESTAMP');
                params.append('history', 'RATING');

                const apiUrl = `https://sc2pulse.nephest.com/sc2/api/team-histories?${params.toString()}`;
                console.log('Fetching:', apiUrl);

                // Use local proxy server to avoid CORS
                const proxyUrl = `/api/proxy?${params.toString()}`;

                const response = await fetch(proxyUrl);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const data = await response.json();
                console.log('Received data:', data);

                if (!data || data.length === 0) {
                    throw new Error('No MMR history found for this account');
                }

                // Parse the API response
                MMR_DATA = {};
                for (const teamData of data) {
                    if (!teamData.staticData || !teamData.history) continue;

                    const legacyId = teamData.staticData.LEGACY_ID;
                    const raceId = legacyId.split('.').pop();
                    const raceName = RACE_MAP[raceId];

                    if (raceName && teamData.history.TIMESTAMP && teamData.history.RATING) {
                        MMR_DATA[raceName] = {
                            timestamps: teamData.history.TIMESTAMP,
                            ratings: teamData.history.RATING
                        };
                    }
                }

                hideLoading();

                if (Object.keys(MMR_DATA).length === 0) {
                    throw new Error('No valid race data found in response');
                }

                return true;
            } catch (error) {
                console.error('Error fetching MMR data:', error);
                hideLoading();
                showError(`Failed to load MMR data: ${error.message}`);
                return false;
            }
        }

        // Aggregate data into candlesticks (OHLC format)
        function aggregateToCandlesticks(timestamps, ratings, periodHours = 24) {
            if (!timestamps || !ratings || timestamps.length === 0) return [];

            const now = Date.now() / 1000;
            let cutoff = currentConfig.timeRange === 'all' ? 0 : now - (currentConfig.timeRange * 24 * 60 * 60);

            // Check if any data would pass the filter
            const maxTimestamp = Math.max(...timestamps);
            if (maxTimestamp < cutoff) {
                // If all data is older than the filter, use all data instead
                console.log('All data is older than time filter, using all data');
                cutoff = 0;
            }

            const periodSeconds = periodHours * 60 * 60;
            const candleMap = new Map();

            // Group data points into time periods
            for (let i = 0; i < timestamps.length; i++) {
                if (timestamps[i] < cutoff) continue;

                const periodKey = Math.floor(timestamps[i] / periodSeconds) * periodSeconds;

                if (!candleMap.has(periodKey)) {
                    candleMap.set(periodKey, {
                        time: periodKey,
                        timeMs: periodKey * 1000,
                        open: ratings[i],
                        high: ratings[i],
                        low: ratings[i],
                        close: ratings[i],
                        values: [ratings[i]]
                    });
                } else {
                    const candle = candleMap.get(periodKey);
                    candle.high = Math.max(candle.high, ratings[i]);
                    candle.low = Math.min(candle.low, ratings[i]);
                    candle.close = ratings[i];
                    candle.values.push(ratings[i]);
                }
            }

            return Array.from(candleMap.values()).sort((a, b) => a.time - b.time);
        }

        // Create all charts
        function createCharts() {
            console.log('=== createCharts called ===');
            console.log('MMR_DATA:', MMR_DATA);

            if (!MMR_DATA || Object.keys(MMR_DATA).length === 0) {
                console.error('No MMR_DATA available');
                return;
            }

            const statsData = [];

            // Get race with most data points
            let selectedRace = null;
            let maxDataPoints = 0;
            for (const [race, data] of Object.entries(MMR_DATA)) {
                const dataPoints = data.timestamps?.length || 0;
                if (dataPoints > maxDataPoints) {
                    maxDataPoints = dataPoints;
                    selectedRace = race;
                }
            }

            if (!selectedRace) {
                console.error('No valid race data found');
                return;
            }

            console.log('Selected race:', selectedRace, 'with', maxDataPoints, 'data points');

            const data = MMR_DATA[selectedRace];
            console.log('Race data:', data);
            console.log('Timestamps length:', data.timestamps?.length);
            console.log('Ratings length:', data.ratings?.length);

            const candleData = aggregateToCandlesticks(data.timestamps, data.ratings, 24);
            console.log('Aggregated candle data length:', candleData.length);
            console.log('Sample candle data:', candleData[0]);

            if (candleData.length === 0) {
                console.error('No candle data after aggregation');
                return;
            }

            // Calculate stats
            const values = data.ratings;
            const min = Math.min(...values);
            const max = Math.max(...values);
            const current = values[values.length - 1];
            const change = current - values[0];
            statsData.push({ race: selectedRace, current, change, min, max });

            // 1. Chart.js
            console.log('Creating Chart.js...');
            createChartJsChart(candleData);

            // 2. Lightweight Charts
            console.log('Creating Lightweight Charts...');
            createLightweightChart(candleData);

            // 3. ECharts
            console.log('Creating ECharts...');
            createEChartsChart(candleData);

            // 4. Highcharts
            console.log('Creating Highcharts...');
            createHighchartsChart(candleData);

            // 5. Plotly
            console.log('Creating Plotly...');
            createPlotlyChart(candleData);

            // 6. ApexCharts
            console.log('Creating ApexCharts...');
            createApexChart(candleData);

            // Update stats
            updateStats(statsData);
            console.log('=== createCharts complete ===');
        }

        // 1. Chart.js Financial Implementation
        function createChartJsChart(candleData) {
            const canvas = document.getElementById('chartjsChart');
            if (!canvas) {
                console.error('Chart.js canvas not found');
                return;
            }

            console.log('[Chart.js] Creating with', candleData.length, 'candles');

            if (charts.chartjs) {
                charts.chartjs.destroy();
                charts.chartjs = null;
            }

            if (candleData.length === 0) {
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#888';
                ctx.font = '14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('No data available', canvas.width / 2, canvas.height / 2);
                return;
            }

            const ctx = canvas.getContext('2d');

            charts.chartjs = new Chart(ctx, {
                type: 'candlestick',
                data: {
                    datasets: [{
                        label: 'MMR',
                        data: candleData.map(c => ({
                            x: c.timeMs,
                            o: c.open,
                            h: c.high,
                            l: c.low,
                            c: c.close
                        })),
                        color: {
                            up: '#00FF00',
                            down: '#FF0000',
                            unchanged: '#888'
                        }
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            type: 'time',
                            grid: { color: 'rgba(255, 255, 255, 0.1)' },
                            ticks: { color: '#888' }
                        },
                        y: {
                            grid: { color: 'rgba(255, 255, 255, 0.1)' },
                            ticks: {
                                color: '#888',
                                callback: (val) => Math.round(val).toLocaleString()
                            }
                        }
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: (context) => {
                                    const point = context.raw;
                                    return [
                                        `Open: ${Math.round(point.o)}`,
                                        `High: ${Math.round(point.h)}`,
                                        `Low: ${Math.round(point.l)}`,
                                        `Close: ${Math.round(point.c)}`
                                    ];
                                }
                            }
                        }
                    }
                }
            });

            console.log('[Chart.js] Created successfully');
        }

        // 2. Lightweight Charts Implementation
        function createLightweightChart(candleData) {
            const container = document.getElementById('lightweightChart');
            if (!container) {
                console.error('Lightweight Charts container not found');
                return;
            }

            console.log('[Lightweight] Creating with', candleData.length, 'candles');

            if (charts.lightweight) {
                charts.lightweight.remove();
            }
            container.innerHTML = '';

            if (candleData.length === 0) {
                container.innerHTML = '<div style="padding: 20px; text-align: center; color: #888;">No data available</div>';
                return;
            }

            const width = container.clientWidth || 400;
            const height = 320;

            charts.lightweight = LightweightCharts.createChart(container, {
                width: width,
                height: height,
                layout: {
                    background: { color: 'transparent' },
                    textColor: '#888'
                },
                grid: {
                    vertLines: { color: 'rgba(255, 255, 255, 0.1)' },
                    horzLines: { color: 'rgba(255, 255, 255, 0.1)' }
                },
                timeScale: { timeVisible: true, secondsVisible: false }
            });

            const series = charts.lightweight.addCandlestickSeries({
                upColor: '#00FF00',
                downColor: '#FF0000',
                borderUpColor: '#00FF00',
                borderDownColor: '#FF0000',
                wickUpColor: '#00FF00',
                wickDownColor: '#FF0000'
            });

            series.setData(candleData.map(c => ({
                time: c.time,
                open: c.open,
                high: c.high,
                low: c.low,
                close: c.close
            })));

            charts.lightweight.timeScale().fitContent();
            console.log('[Lightweight] Created successfully');
        }

        // 3. ECharts Implementation
        function createEChartsChart(candleData) {
            const container = document.getElementById('echartsChart');
            if (!container) {
                console.error('ECharts container not found');
                return;
            }

            console.log('[ECharts] Creating with', candleData.length, 'candles');

            if (charts.echarts) {
                charts.echarts.dispose();
            }
            container.innerHTML = '';

            if (candleData.length === 0) {
                container.innerHTML = '<div style="padding: 20px; text-align: center; color: #888;">No data available</div>';
                return;
            }

            charts.echarts = echarts.init(container);

            // ECharts needs data in format: [open, close, low, high]
            const data = candleData.map(c => [c.open, c.close, c.low, c.high]);
            const dates = candleData.map(c => new Date(c.timeMs).toLocaleDateString());

            const option = {
                backgroundColor: 'transparent',
                tooltip: {
                    trigger: 'axis',
                    axisPointer: { type: 'cross' },
                    backgroundColor: 'rgba(0, 0, 0, 0.9)',
                    borderColor: 'rgba(0, 212, 255, 0.5)',
                    textStyle: { color: '#e0e0e0' }
                },
                grid: {
                    left: '10%',
                    right: '5%',
                    bottom: '15%',
                    top: '5%'
                },
                xAxis: {
                    type: 'category',
                    data: dates,
                    axisLine: { lineStyle: { color: '#888' } },
                    splitLine: { lineStyle: { color: 'rgba(255, 255, 255, 0.1)' } }
                },
                yAxis: {
                    scale: true,
                    axisLine: { lineStyle: { color: '#888' } },
                    splitLine: { lineStyle: { color: 'rgba(255, 255, 255, 0.1)' } }
                },
                series: [{
                    type: 'candlestick',
                    name: 'MMR',
                    data: data,
                    itemStyle: {
                        color: '#00FF00',
                        color0: '#FF0000',
                        borderColor: '#00FF00',
                        borderColor0: '#FF0000'
                    }
                }]
            };

            charts.echarts.setOption(option);
            console.log('[ECharts] Created successfully');
        }

        // 4. Highcharts Implementation
        function createHighchartsChart(candleData) {
            const container = document.getElementById('highchartsChart');
            if (!container) {
                console.error('Highcharts container not found');
                return;
            }

            console.log('[Highcharts] Creating with', candleData.length, 'candles');
            container.innerHTML = '';

            if (candleData.length === 0) {
                container.innerHTML = '<div style="padding: 20px; text-align: center; color: #888;">No data available</div>';
                return;
            }

            // Highcharts needs data in format: [timestamp, open, high, low, close]
            const data = candleData.map(c => [c.timeMs, c.open, c.high, c.low, c.close]);

            charts.highcharts = Highcharts.stockChart(container, {
                chart: {
                    backgroundColor: 'transparent',
                    height: 320
                },
                rangeSelector: { enabled: false },
                navigator: { enabled: false },
                scrollbar: { enabled: false },
                credits: { enabled: false },
                xAxis: {
                    gridLineColor: 'rgba(255, 255, 255, 0.1)',
                    labels: { style: { color: '#888' } }
                },
                yAxis: {
                    gridLineColor: 'rgba(255, 255, 255, 0.1)',
                    labels: { style: { color: '#888' } }
                },
                series: [{
                    type: 'candlestick',
                    name: 'MMR',
                    data: data,
                    color: '#FF0000',
                    upColor: '#00FF00',
                    lineColor: '#FF0000',
                    upLineColor: '#00FF00'
                }],
                tooltip: {
                    backgroundColor: 'rgba(0, 0, 0, 0.9)',
                    borderColor: 'rgba(0, 212, 255, 0.5)',
                    style: { color: '#e0e0e0' }
                }
            });

            console.log('[Highcharts] Created successfully');
        }

        // 5. Plotly.js Implementation
        function createPlotlyChart(candleData) {
            const container = document.getElementById('plotlyChart');
            if (!container) {
                console.error('Plotly container not found');
                return;
            }

            console.log('[Plotly] Creating with', candleData.length, 'candles');

            if (candleData.length === 0) {
                container.innerHTML = '<div style="padding: 20px; text-align: center; color: #888;">No data available</div>';
                return;
            }

            const trace = {
                x: candleData.map(c => new Date(c.timeMs)),
                close: candleData.map(c => c.close),
                high: candleData.map(c => c.high),
                low: candleData.map(c => c.low),
                open: candleData.map(c => c.open),
                type: 'candlestick',
                name: 'MMR',
                increasing: {
                    line: { color: '#00FF00', width: 1 },
                    fillcolor: '#00FF00'
                },
                decreasing: {
                    line: { color: '#FF0000', width: 1 },
                    fillcolor: '#FF0000'
                }
            };

            const layout = {
                paper_bgcolor: 'transparent',
                plot_bgcolor: 'rgba(0, 0, 0, 0.1)',
                font: { color: '#888' },
                xaxis: {
                    gridcolor: 'rgba(255, 255, 255, 0.1)',
                    rangeslider: { visible: false },
                    color: '#888'
                },
                yaxis: {
                    gridcolor: 'rgba(255, 255, 255, 0.1)',
                    color: '#888'
                },
                margin: { l: 60, r: 30, t: 10, b: 40 },
                height: 320,
                showlegend: false
            };

            Plotly.newPlot(container, [trace], layout, {
                responsive: true,
                displayModeBar: false,
                displaylogo: false
            });

            console.log('[Plotly] Created successfully');
        }

        // 6. ApexCharts Implementation
        function createApexChart(candleData) {
            const container = document.getElementById('apexChart');
            if (!container) {
                console.error('ApexCharts container not found');
                return;
            }

            console.log('[ApexCharts] Creating with', candleData.length, 'candles');

            if (charts.apex) {
                charts.apex.destroy();
            }
            container.innerHTML = '';

            if (candleData.length === 0) {
                container.innerHTML = '<div style="padding: 20px; text-align: center; color: #888;">No data available</div>';
                return;
            }

            const seriesData = candleData.map(c => ({
                x: c.timeMs,
                y: [c.open, c.high, c.low, c.close]
            }));

            const options = {
                series: [{ name: 'MMR', data: seriesData }],
                chart: {
                    type: 'candlestick',
                    height: 320,
                    background: 'transparent',
                    foreColor: '#888',
                    toolbar: { show: false }
                },
                plotOptions: {
                    candlestick: {
                        colors: { upward: '#00FF00', downward: '#FF0000' },
                        wick: { useFillColor: true }
                    }
                },
                xaxis: {
                    type: 'datetime',
                    labels: { style: { colors: '#888' } }
                },
                yaxis: {
                    labels: {
                        style: { colors: '#888' },
                        formatter: (val) => val ? Math.round(val).toLocaleString() : ''
                    }
                },
                grid: { borderColor: 'rgba(255, 255, 255, 0.1)' },
                tooltip: {
                    theme: 'dark',
                    x: { format: 'yyyy-MM-dd' }
                }
            };

            charts.apex = new ApexCharts(container, options);
            charts.apex.render();
            console.log('[ApexCharts] Created successfully');
        }
        // UI helper functions
        function showLoading() {
            const chartContainer = document.querySelector('.charts-grid');
            let loading = document.getElementById('loading');
            if (!loading) {
                loading = document.createElement('div');
                loading.id = 'loading';
                loading.className = 'loading';
                loading.textContent = 'Loading MMR data from SC2 Pulse...';
                chartContainer.parentElement.insertBefore(loading, chartContainer);
            }
            chartContainer.style.opacity = '0.3';
        }

        function hideLoading() {
            const loading = document.getElementById('loading');
            if (loading) loading.remove();
            const chartContainer = document.querySelector('.charts-grid');
            if (chartContainer) chartContainer.style.opacity = '1';
        }

        function showError(message) {
            let errorDiv = document.getElementById('error');
            if (!errorDiv) {
                errorDiv = document.createElement('div');
                errorDiv.id = 'error';
                errorDiv.className = 'error';
                document.querySelector('.container').insertBefore(errorDiv, document.querySelector('.controls'));
            }
            errorDiv.textContent = 'âŒ ' + message;
        }

        function hideError() {
            const errorDiv = document.getElementById('error');
            if (errorDiv) errorDiv.remove();
        }

        // Update statistics
        function updateStats(statsData) {
            const statsContainer = document.getElementById('stats');
            statsContainer.innerHTML = '';

            statsData.forEach(({ race, current, change, min, max }) => {
                const card = document.createElement('div');
                card.className = `stat-card ${race}`;
                card.innerHTML = `
                    <div class="stat-label">${race.charAt(0).toUpperCase() + race.slice(1)}</div>
                    <div class="stat-value">${current.toLocaleString()}</div>
                    <div class="stat-label">Change: ${change >= 0 ? '+' : ''}${change}</div>
                    <div class="stat-label">Range: ${min.toLocaleString()} - ${max.toLocaleString()}</div>
                `;
                statsContainer.appendChild(card);
            });
        }

        // Event listeners
        document.getElementById('loadData').addEventListener('click', async () => {
            const success = await fetchMmrData();
            if (success) {
                createCharts();
            }
        });

        document.getElementById('timeRange').addEventListener('change', (e) => {
            currentConfig.timeRange = e.target.value === 'all' ? 'all' : parseInt(e.target.value);
            if (MMR_DATA) createCharts();
        });

        document.getElementById('chartType').addEventListener('change', () => {
            if (MMR_DATA) createCharts();
        });

        document.getElementById('performance').addEventListener('change', () => {
            if (MMR_DATA) createCharts();
        });

        document.getElementById('yAxisStart').addEventListener('change', () => {
            if (MMR_DATA) createCharts();
        });

        document.getElementById('resetZoom').addEventListener('click', () => {
            if (MMR_DATA) createCharts();
        });

        document.getElementById('accountId').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                document.getElementById('loadData').click();
            }
        });

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('loadData').click();
        });
    </script>
</body>

</html>